#!/usr/bin/env python3
"""Generate header-only loader implementation from the API manifest.

This script reads the grouped API manifest and generates bml_loader_autogen.h,
which provides the API loader implementation and declarations.

Usage:
    python generate_bml_loader.py [--root <repo_root>]
"""

from __future__ import annotations

import argparse
import json
import re
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

HEADER = """// -----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by tools/generate_bml_loader.py.
//     Do not edit this file directly. Instead, update the manifest or script.
//
//     Manifest: tools/bml_loader_manifest.json
//     Generated from {api_count} APIs in {group_count} groups.
// </auto-generated>
// -----------------------------------------------------------------------------
"""


@dataclass(frozen=True)
class ManifestEntry:
    """Represents a single API entry in the manifest."""
    pointer: str
    required: bool
    group: str


@dataclass(frozen=True)
class ManifestGroup:
    """Represents a group of related APIs."""
    name: str
    header: str
    apis: list[ManifestEntry]


RE_EXTERN = re.compile(r"extern\s+(?P<type>[A-Za-z0-9_]+)\s+(?P<pointer>bml[A-Za-z0-9_]+)\s*;")


def load_manifest(manifest_path: Path) -> tuple[list[ManifestGroup], list[ManifestEntry]]:
    """Load and parse the manifest file.
    
    Returns:
        Tuple of (groups, flat_entries) where flat_entries maintains order.
    """
    data = json.loads(manifest_path.read_text(encoding="utf-8"))
    
    # Support both old flat format and new grouped format
    if "groups" in data:
        groups = []
        flat_entries = []
        seen = set()
        
        for group_data in data["groups"]:
            name = group_data.get("name", "Unknown")
            header = group_data.get("header", "")
            apis = group_data.get("apis", [])
            
            group_entries = []
            for api in apis:
                pointer = api.get("pointer")
                if not isinstance(pointer, str):
                    raise ValueError(f"Invalid pointer in group '{name}'")
                if pointer in seen:
                    raise ValueError(f"Duplicate pointer '{pointer}' in manifest")
                seen.add(pointer)
                
                required = bool(api.get("required", True))
                entry = ManifestEntry(pointer=pointer, required=required, group=name)
                group_entries.append(entry)
                flat_entries.append(entry)
            
            groups.append(ManifestGroup(name=name, header=header, apis=group_entries))
        
        return groups, flat_entries
    
    # Legacy flat format support
    apis = data.get("apis", [])
    if not isinstance(apis, list):
        raise ValueError("Manifest 'apis' must be a list")
    
    flat_entries = []
    seen = set()
    for entry in apis:
        pointer = entry.get("pointer")
        if not isinstance(pointer, str):
            raise ValueError("Each entry must contain a string 'pointer'")
        if pointer in seen:
            raise ValueError(f"Duplicate pointer '{pointer}' in manifest")
        seen.add(pointer)
        required = bool(entry.get("required", True))
        flat_entries.append(ManifestEntry(pointer=pointer, required=required, group=""))
    
    return [], flat_entries


def collect_pointer_types(include_root: Path) -> dict[str, str]:
    """Scan header files to collect pointer type information."""
    pointer_types: dict[str, str] = {}
    for header_path in include_root.glob("bml_*.h"):
        # Skip auto-generated file
        if header_path.name == "bml_loader_autogen.h":
            continue
        text = header_path.read_text(encoding="utf-8")
        for match in RE_EXTERN.finditer(text):
            pointer = match.group("pointer")
            pointer_types[pointer] = match.group("type")
    if not pointer_types:
        raise RuntimeError("No extern pointers found under include/")
    return pointer_types


def render_pointer_definitions(entries: list[ManifestEntry], pointer_types: dict[str, str], 
                                groups: list[ManifestGroup]) -> str:
    """Generate pointer variable definitions with group comments."""
    lines = []
    
    if groups:
        for group in groups:
            if group.apis:
                lines.append(f"/* {group.name} APIs ({group.header}) */")
                for entry in group.apis:
                    type_name = pointer_types[entry.pointer]
                    lines.append(f"{type_name} {entry.pointer} = NULL;")
                lines.append("")
    else:
        for entry in entries:
            type_name = pointer_types[entry.pointer]
            lines.append(f"{type_name} {entry.pointer} = NULL;")
    
    return "\n".join(lines).rstrip()


def render_reset_function(entries: list[ManifestEntry]) -> str:
    """Generate the reset function."""
    lines = ["static void bmlResetApiPointers(void) {"]
    lines.extend(f"    {entry.pointer} = NULL;" for entry in entries)
    lines.append("}")
    return "\n".join(lines)


def render_entries_array(entries: list[ManifestEntry], groups: list[ManifestGroup]) -> str:
    """Generate the API entries array with group comments."""
    lines = ["static const BML_ApiEntry kBmlApiEntries[] = {"]
    
    if groups:
        for group in groups:
            if group.apis:
                lines.append(f"    /* {group.name} */")
                for entry in group.apis:
                    required = "1" if entry.required else "0"
                    lines.append(f'    {{"{entry.pointer}", BML_ASSIGN_PTR({entry.pointer}), {required}}},')
    else:
        for entry in entries:
            required = "1" if entry.required else "0"
            lines.append(f'    {{"{entry.pointer}", BML_ASSIGN_PTR({entry.pointer}), {required}}},')
    
    lines.append("};")
    return "\n".join(lines)


def generate_loader(root: Path) -> str:
    """Generate the complete loader header content."""
    manifest_path = root / "tools" / "bml_loader_manifest.json"
    
    groups, entries = load_manifest(manifest_path)
    pointer_types = collect_pointer_types(root / "include")
    
    # Validate all pointers exist in headers
    missing = [e.pointer for e in entries if e.pointer not in pointer_types]
    if missing:
        raise RuntimeError(f"Pointers missing from headers: {', '.join(missing)}")
    
    pointer_definitions = render_pointer_definitions(entries, pointer_types, groups)
    reset_function = render_reset_function(entries)
    entries_array = render_entries_array(entries, groups)
    
    # Statistics
    api_count = len(entries)
    group_count = len(groups)
    required_count = sum(1 for e in entries if e.required)
    optional_count = api_count - required_count
    
    header = HEADER.format(api_count=api_count, group_count=group_count)
    
    entry_count = "(sizeof(kBmlApiEntries) / sizeof(kBmlApiEntries[0]))"
    
    body_lines = [
        "#ifndef BML_LOADER_AUTOGEN_H",
        "#define BML_LOADER_AUTOGEN_H",
        "",
        f"/* Total: {api_count} APIs ({required_count} required, {optional_count} optional) */",
        "",
        "#ifdef BML_LOADER_IMPLEMENTATION",
        "",
        "/* ========================================================================",
        " * API Pointer Definitions",
        " * ======================================================================== */",
        "",
        pointer_definitions,
        "",
        "/* ========================================================================",
        " * Internal Implementation",
        " * ======================================================================== */",
        "",
        "#define BML_ASSIGN_PTR(name) ((void **)&(name))",
        "",
        "typedef struct BML_ApiEntry {",
        "    const char *name;",
        "    void **target;",
        "    int required;",
        "} BML_ApiEntry;",
        "",
        reset_function,
        "",
        entries_array,
        "",
        "/* ========================================================================",
        " * Public Loader Functions",
        " * ======================================================================== */",
        "",
        "BML_Result bmlLoadAPI(PFN_BML_GetProcAddress get_proc) {",
        "    size_t i;",
        "",
        "    if (!get_proc)",
        "        return BML_RESULT_INVALID_ARGUMENT;",
        "",
        "    for (i = 0; i < " + entry_count + "; ++i) {",
        "        void *proc = get_proc(kBmlApiEntries[i].name);",
        "        if (!proc) {",
        "            if (kBmlApiEntries[i].required) {",
        "                bmlUnloadAPI();",
        "                return BML_RESULT_NOT_FOUND;",
        "            }",
        "            continue;",
        "        }",
        "        *kBmlApiEntries[i].target = proc;",
        "    }",
        "",
        "    return BML_RESULT_OK;",
        "}",
        "",
        "void bmlUnloadAPI(void) {",
        "    bmlResetApiPointers();",
        "}",
        "",
        "BML_Bool bmlIsApiLoaded(void) {",
        "    return (bmlContextRetain != NULL) ? BML_TRUE : BML_FALSE;",
        "}",
        "",
        f"size_t bmlGetApiCount(void) {{",
        f"    return {api_count};",
        "}",
        "",
        f"size_t bmlGetRequiredApiCount(void) {{",
        f"    return {required_count};",
        "}",
        "",
        "#undef BML_ASSIGN_PTR",
        "",
        "#endif /* BML_LOADER_IMPLEMENTATION */",
        "",
        "#endif /* BML_LOADER_AUTOGEN_H */",
    ]
    
    return header + "\n".join(body_lines) + "\n"


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Generate header-only loader implementation from manifest",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    python generate_bml_loader.py
    python generate_bml_loader.py --root /path/to/repo
        """
    )
    parser.add_argument("--root", type=Path, default=Path(__file__).resolve().parents[1],
                        help="Repository root (defaults to script parent)")
    args = parser.parse_args()
    
    root = args.root.resolve()
    output = generate_loader(root)
    output_path = root / "include" / "bml_loader_autogen.h"
    output_path.write_text(output, encoding="utf-8")
    
    # Print summary
    manifest_path = root / "tools" / "bml_loader_manifest.json"
    groups, entries = load_manifest(manifest_path)
    required = sum(1 for e in entries if e.required)
    print(f"Updated {output_path}")
    print(f"  Groups: {len(groups)}")
    print(f"  APIs: {len(entries)} ({required} required, {len(entries) - required} optional)")


if __name__ == "__main__":
    main()
